import Foundation
import PythonKit
import CommandLineKit
import Defile

// MARK: CommandLine Processing
let cli = CommandLineKit.CommandLine()

let tvAttemptsDefault = "20"

//let filePath = StringOption(shortFlag: "o", longFlag: "outputFile", required: true, helpMessage: "Path to the output file.")
let netlist = StringOption(shortFlag: "n", longFlag: "netlistSimulationFile", required: true, helpMessage: ".v file describing the netlist.")
let testVectorAttempts = StringOption(shortFlag: "a", longFlag: "attempts", helpMessage: "Number of attempts to generate a test vector. (Default: \(tvAttemptsDefault))")
let help = BoolOption(shortFlag: "h", longFlag: "help", helpMessage: "Prints a help message.")

cli.addOptions(netlist, testVectorAttempts, help)

do {
    try cli.parse()
} catch {
    cli.printUsage()
    exit(EX_USAGE)
}

if help.value {
    cli.printUsage()
    exit(0)
}

let args = cli.unparsedArguments
if args.count != 1 {
    cli.printUsage()
    exit(EX_USAGE)
}

guard let tvAttempts = Int(testVectorAttempts.value ?? tvAttemptsDefault) else {
    cli.printUsage()
    exit(EX_USAGE)
}

// MARK: Importing Python and Pyverilog
let sys = Python.import("sys")
sys.path.append(FileManager().currentDirectoryPath + "/Pyverilog")

let version = Python.import("pyverilog.utils.version")
print("Using Pyverilog v\(version.VERSION)")

let parse = Python.import("pyverilog.vparser.parser").parse

// MARK: Parsing and Processing
let ast = parse([args[0]])[0]
let definition = ast[dynamicMember: "description"].definitions[1]

print("Processing module \(definition.name)...")

var ports = [String: Port]()

for portDeclaration in  definition.portlist.ports {
    let port = Port(name: "\(portDeclaration.name)")
    ports["\(portDeclaration.name)"] = port
}

var faultPoints = Set<String>()

for itemDeclaration in definition.items {
    let type = Python.type(itemDeclaration).__name__

    // Process port declarations further
    if type == "Decl" {
        let declaration = itemDeclaration.list[0]
        let declType = Python.type(declaration).__name__
        if declType == "Input" || declType == "Output" {
            guard let port = ports["\(declaration.name)"] else {
                print("Parse error: Unknown port.")
                exit(EX_DATAERR)
            }
            if declaration.width != Python.None {
                port.from = Int("\(declaration.width.msb)")!
                port.to = Int("\(declaration.width.lsb)")!
            }
            if (declType == "Input") {
                port.polarity = .input
            } else {
                port.polarity = .output
            }
        }
    }

    // Process gates
    if type == "InstanceList" {
        let instance = itemDeclaration.instances[0]
        for hook in instance.portlist {
            let name = "\(hook.argname)"
            faultPoints.insert(name)
        }
    }
}
print("Found ports...")
print(ports)
print("Found fault points...")
print(faultPoints)

// Separate Inputs and Outputs
var inputs = [Port]()
var outputs = [Port]()

for (_, port) in ports {
    if port.polarity == .input {
        inputs.append(port)
    }
    if port.polarity == .output {
        outputs.append(port)
    }
}

if (inputs.count == 0) {
    print("Module has no inputs.")
    exit(0)
}
if (outputs.count == 0) {
    print("Module has no outputs.")
    exit(0)
}

func generateTestbench(for module: String, ports: [String: Port], faultPoint: String, stuckAt: Int) {
    let dateFormatter = DateFormatter()
    dateFormatter.dateFormat = "yyyy-MM-dd HH:mm:ss"
    let date = Date()
    let dateString = dateFormatter.string(from: date)

    var portWires = ""
    var portHooks = ""

    for (name, port) in ports {
        portWires += "    \(port.polarity == .input ? "reg" : "wire")[\(port.to):\(port.from)] \(name);\n"
        portHooks += ".\(name)(\(name)), "
    }

    let folderName = "faultTest\(UInt16.random(in: 0..<UInt16.max))"
    let _ = "mkdir -p \(folderName)".sh()

    var finalVector: [String: UInt]? = nil

    // in loop?
    for _ in 0..<tvAttempts {
        var inputAssignment = ""

        var vector = [String: UInt]()
        for input in inputs {
            let num = UInt.random(in: 0...UInt.max)
            vector[input.name] = num
            inputAssignment += "        \(input.name) = \(num);\n"
        }

        let vcdName = "\(folderName)/dump.vcd";
        let vcdGMName = "\(folderName)/dumpGM.vcd";

        let bench = """
        /*
            Automatically generated by Fault
            Do not modify.
            Generated on: \(dateString)
        */

        `include "\(netlist.value!)"
        `include "\(args[0])"

        module FaultTestbench;

        \(portWires)

            \(module) uut(
                \(portHooks.dropLast(2))
            );
            
            `ifdef FAULT_WITH
            initial force uut.\(faultPoint) = \(stuckAt);
            `endif

            initial begin
                $dumpfile("\(vcdName)");
                $dumpvars(0, FaultTestbench);
        \(inputAssignment)
                #100;
                $finish;
            end

        endmodule
        """;

        let tbName = "\(folderName)/tb.sv"
        File.open(tbName, mode: .write) {
            try! $0.print(bench)
        }

        let aoutName = "\(folderName)/a.out"

        // Test GM
        let iverilogGMResult = "iverilog -Ttyp -o \(aoutName) \(tbName) 2>&1 > /dev/null".sh()
        if iverilogGMResult != EX_OK {
            exit(Int32(iverilogGMResult))
        }
        let vvpGMResult = "vvp \(aoutName) > /dev/null".sh()
        if vvpGMResult != EX_OK {
            exit(Int32(vvpGMResult))
        }

        let _ = "mv '\(vcdName)' '\(vcdGMName)'".sh()

        let iverilogResult = "iverilog -Ttyp -D FAULT_WITH -o \(aoutName) \(tbName) ".sh()
        if iverilogResult != EX_OK {
            exit(Int32(iverilogGMResult))
        }
        let vvpResult = "vvp \(aoutName) > /dev/null".sh()
        if vvpResult != EX_OK {
            exit(Int32(vvpGMResult))
        }

        let difference = "diff \(vcdName) \(vcdGMName) > /dev/null".sh() == 1
        if (difference) {
            finalVector = vector
            break
        } else {
            //print("Vector \(vector) not viable for \(faultPoint) stuck at \(stuckAt)")
        }
    }

    if let testVector = finalVector {
        print("Vector found for \(faultPoint) stuck at \(stuckAt):", testVector)
    } else {
        print("Vector not found for \(faultPoint) stuck at \(stuckAt)")
    }

    let _ = "rm -rf \(folderName)".sh()
}

for point in faultPoints {
    generateTestbench(for: "\(definition.name)", ports: ports, faultPoint: point, stuckAt: 0)
    generateTestbench(for: "\(definition.name)", ports: ports, faultPoint: point, stuckAt: 1)
}